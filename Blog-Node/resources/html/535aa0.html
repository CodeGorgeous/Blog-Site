<h1 id="typescript"><a href="https://www.typescriptlang.org/">TypeScript</a></h1>
<h2 id="优势">优势</h2>
<ol>
<li>静态</li>
<li>可选</li>
<li>强类型</li>
</ol>
<h2 id="环境搭建">环境搭建</h2>
<ol>
<li>npm i <a href="https://www.npmjs.com/package/typescript">typescript</a> -g</li>
<li>使用命令行tsc 文件名进行编译</li>
</ol>
<h2 id="配置">配置</h2>
<ul>
<li>tsc命令<ul>
<li>命令后续加上选项参数</li>
</ul>
</li>
<li>配置文件<ul>
<li>tsconfig.json(可通过tsc --init来创建这个文件)</li>
<li>compilerOptions<ul>
<li>Object</li>
<li>编译选项<ul>
<li>target<ul>
<li>String</li>
<li>配置编译后的代码版本标准</li>
</ul>
</li>
<li>module<ul>
<li>String</li>
<li>配置编译后的代码模块化标准</li>
</ul>
</li>
<li>lib<ul>
<li>String[]</li>
<li>配置默认情况下代码的环境</li>
</ul>
</li>
<li>outDir<ul>
<li>String</li>
<li>配置编译后文件的输出位置</li>
</ul>
</li>
<li>strictNullChecks<ul>
<li>Boolean</li>
<li>是否开启更加严格的空类型检查</li>
</ul>
</li>
<li>removeComments<ul>
<li>Boolean</li>
<li>是否编译时保留注释</li>
</ul>
</li>
<li>esModuleInterop<ul>
<li>Boolean</li>
<li>是否启用es模块化交互非es模块导出</li>
</ul>
</li>
<li>noEmitOnError<ul>
<li>Boolean</li>
<li>ts代码有误的情况下是否取消编译, 并继续编译正确代码</li>
</ul>
</li>
<li>noImplicitUseStrict<ul>
<li>Boolean</li>
<li>编译后的代码是否自动增添<code>&quot;use strict&quot;</code></li>
</ul>
</li>
<li>moduleResolution<ul>
<li>String</li>
<li>配置模块解析策略</li>
</ul>
</li>
<li>strictPropertyInitialization<ul>
<li>Boolean</li>
<li>更加严格的检查类中的值是否初始化</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>include<ul>
<li>String[]</li>
<li>配置需要编译的文件夹</li>
</ul>
</li>
<li>files<ul>
<li>String[]</li>
<li>单独配置需要编译的文件</li>
</ul>
</li>
</ul>
</li>
<li>第三方库<ul>
<li><a href="https://www.npmjs.com/package/ts-node">ts-node</a><ul>
<li>直接将ts代码在内存中完成编译并完成运行</li>
<li>命令 ts-node 文件路径</li>
</ul>
</li>
<li><a href="https://www.npmjs.com/package/nodemon">nodemon</a><ul>
<li>监测文件变化</li>
<li>命令 nodemon --watch ./src -e ts --exec ts-node ./src/index.ts<ul>
<li>此段命令意为当src文件夹下文件且文件后缀名为ts发生变化时运行ts-node ./src/index.ts该命令</li>
</ul>
</li>
</ul>
</li>
<li><a href="https://www.npmjs.com/package/@types/node">@types/node</a><ul>
<li>用于向代码环境中增添node环境</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="类型约束">类型约束</h2>
<h3 id="可以用于约束变量、函数参数、函数返回等">可以用于约束变量、函数参数、函数返回等</h3>
<ul>
<li>所有类型约束<ul>
<li>: string<ul>
<li>约束为字符串类型</li>
</ul>
</li>
<li>: number<ul>
<li>约束为数字类型</li>
</ul>
</li>
<li>: boolean<ul>
<li>约束为布尔类型</li>
</ul>
</li>
<li>: number[] / : string[] / : boolean[] / : object[]<ul>
<li>约束为由数字/字符串/布尔/对象组成的数组类型</li>
<li>第二种写法为 : Array<number> / : Array<string> / : Array<boolean> / : Array<object></li>
</ul>
</li>
<li>: object<ul>
<li>约束为对象类型</li>
</ul>
</li>
<li>: any<ul>
<li>约束为任意类型</li>
<li>可以跳过类型检查</li>
</ul>
</li>
<li>: undefined<ul>
<li>约定为undefined类型</li>
<li><strong>特别注意:</strong> 在配置文件未开启strictNullChecks时, undefined是可以被赋值在string类型上存在的</li>
</ul>
</li>
<li>: null<ul>
<li>约定为null类型</li>
<li><strong>特别注意:</strong> 在配置文件未开启strictNullChecks时, null是可以被赋值在string类型上存在的</li>
</ul>
</li>
<li>: string | undefined / : number | null / ...<ul>
<li>约定为字符串或者undefined类型/数字或者null等等</li>
</ul>
</li>
<li>: void<ul>
<li>一般用于约束函数不能返回任意值</li>
</ul>
</li>
<li>: never<ul>
<li>一般用于约束函数永远不会结束</li>
<li>例如: 死循环、抛出错误...</li>
</ul>
</li>
<li>: 字面量1<ul>
<li>一般用于约束变量限定在某个值</li>
<li>例如: let sex: &quot;男&quot; | &quot;女&quot;;   这样sex就只能从男/女中取值</li>
</ul>
</li>
<li>: [string, boolean, number]<ul>
<li>约定为一个固定长度的数组, 自定义数组内每个位置的数据类型</li>
</ul>
</li>
</ul>
</li>
</ul>
<pre><code class="language-ts">    let str1: string = &#39;Code&#39;
    let num1: number = 1
    let bool1: boolean = true
    let any1: any = &#39;123&#39;
    let boolArr: boolean[] = [true, true]
    let obj1: object = {}
    let name1: string | undefined = undefined


    function sum(a: number, b: number): number {
        return a + b
    }

    function demo1(): void {
        console.log(&#39;芜湖&#39;)
    }

    function demo2(): never {
        throw new Error(&#39;已错误&#39;)
    }

    let sex: &quot;男&quot; | &quot;女&quot;;
    // sex = 1 // 报错
    sex = &quot;男&quot;

    let arr1: [string, boolean]
</code></pre>
<h2 id="类型别名">类型别名</h2>
<h3 id="对一直的一些类型定义为固定名称-方便之后使用-通过关键字type进行定义">对一直的一些类型定义为固定名称, 方便之后使用, 通过关键字type进行定义</h3>
<pre><code class="language-ts">    // 定义一个类型别名
    type Name = string
    type Age = number
    type Sex = &quot;男&quot; | &quot;女&quot;

    // 可以嵌套使用类型别名
    type User = {
        name: Name,
        age: Age,
        sex: Sex
    }

    let user1: User = {
        name: &#39;maomao&#39;,
        age: 18,
        sex: &quot;女&quot;
    }

    function getAllUser(): User[] {
        return [{
            name: &#39;maomao&#39;,
            age: 18,
            sex: &quot;女&quot;
        }, {
            name: &#39;CodeGorgeous&#39;,
            age: 21,
            sex: &quot;男&quot;
        }]
    }
</code></pre>
<h3 id="类型别名可实现类似于接口继承的效果-使用关键字进行链接-这种称之为交叉类型">类型别名可实现类似于接口继承的效果, 使用``&amp;```关键字进行链接, 这种称之为交叉类型</h3>
<pre><code class="language-ts">    type A = {
        name: string
    }

    type B = {
        age: number
    }

    type C = {
        phone: string
    } &amp; A &amp; B

    const user: C = {
        name: &#39;CodeGorgeous&#39;,
        age: 21,
        phone: &quot;176xxxx0940&quot;
    }
</code></pre>
<h2 id="函数的约束">函数的约束</h2>
<h3 id="函数重载-在函数实现前-对于函数的多种情况进行声明">函数重载, 在函数实现前, 对于函数的多种情况进行声明</h3>
<pre><code class="language-ts">    function merge(a: string, b: string): string
    function merge(a: number, b: number): number

    function merge(a: string | number, b: string | number): string | number {
        if (typeof a === &#39;string&#39; &amp;&amp; typeof b === &#39;string&#39;) return a + b
        else if (typeof a === &#39;number&#39; &amp;&amp; typeof b === &#39;number&#39;) return a + b
        else throw new Error(&#39;传入的两个参数类型不一致&#39;)
    }
    
    // merge(1,&quot;2&quot;) // 报错
    merge(1,2) // number
    merge(&quot;1&quot;, &quot;2&quot;) // string
</code></pre>
<h3 id="可选参数-选择个别参数">可选参数, 选择个别参数</h3>
<pre><code class="language-ts">    /**
     * 得到两数乘积
     * @param a 
     * @param b 
     */
    function merge(a: number, b: number): number
    /**
     * 得到拼接结果
     * @param a 
     * @param b 
     * @param c 
     */
    function merge(a:number, b: number, c: string): string

    function merge(a: number, b: number, c?: string) {
        if (c) {
            return a + b + c
        } else {
            return a * b
        }
    }
</code></pre>
<h2 id="poker小练习">Poker小练习</h2>
<pre><code class="language-ts">    class Poker {
        pokerPoint: string[]
        color: string []
        poker: string []

        constructor() {
            this.pokerPoint = [&quot;1&quot;, &quot;2&quot;, &quot;3&quot;, &quot;4&quot;, &quot;5&quot;, &quot;6&quot;, &quot;7&quot;, &quot;8&quot;, &quot;9&quot;, &quot;10&quot;, &quot;J&quot;, &quot;Q&quot;, &quot;K&quot;]
            this.color = [&quot;♣&quot;, &quot;♦&quot;, &quot;♠&quot;, &quot;♥&quot;]
            this.poker = []
        }
        // 创建牌组
        createPoker(ifLock?: boolean) {
            for (const iterator of this.pokerPoint) {
                for (const color of this.color) {
                    this.poker = [...this.poker, `${color}${iterator}`]
                }
            }
            if (ifLock) { // 说明需要54张排
                this.poker = [...this.poker, &#39;joker&#39;, &quot;JOKER&quot;]
            }
        }
        // 看牌
        printPoker() {
            for (const iterator of this.poker) {
                console.log(iterator)
            }
        }
        // 洗牌
        upsetPoker() {
            this.poker.sort(item =&gt; {
                return Math.random() - 0.5
            })
        }
    }

    const poker = new Poker()
    poker.createPoker(true)
    poker.printPoker()
    console.log(&#39;开始打乱顺序&#39;)
    poker.upsetPoker()
    poker.printPoker()
</code></pre>
<h2 id="枚举">枚举</h2>
<h3 id="用于约束值在某个范围的进行取得-解决真实值与逻辑含义的混淆-减少重复代码-使用关键字enum定义枚举">用于约束值在某个范围的进行取得, 解决真实值与逻辑含义的混淆, 减少重复代码, 使用关键字enum定义枚举</h3>
<ul>
<li>枚举规则<ul>
<li>enum xxx {key: value, key1: value1}</li>
<li>value只能为字符串/数字</li>
<li>value为数字时会进行自增</li>
<li>一个枚举的value一定不要同时出现string和number</li>
</ul>
</li>
</ul>
<pre><code class="language-ts">    enum Sex {
        male = &#39;男&#39;,
        female = &#39;女&#39;
    }
    console.log(Sex) // { male: &quot;男&quot;, female: &#39;女}
    const user1 = {
        name: &#39;maomao&#39;,
        sex: Sex.female
    }

    const user2 = {
        name: &#39;CodeGorgeous&#39;,
        sex: Sex.male
    }

    console.log(user1, user2) // { name: &#39;maomao&#39;, sex: &#39;女&#39; } { name: &#39;CodeGorgeous&#39;, sex: &#39;男&#39; }
    
    enum Level {
        level1,
        level2,
        level3,
        level4 = 9,
        level5,
        level6
    }

    console.log(Level)
</code></pre>
<h2 id="ts中的模块化">Ts中的模块化</h2>
<h3 id="在ts中使用模块化和正常使用模块化一致-注意-导入的文件名不要带上后缀名ts-否则会报错-使用es6模块化标准或者commonjs标准都可以-可以通过配置module来控制编译后js文件使用的模块化标准">在Ts中使用模块化和正常使用模块化一致, <strong>注意: 导入的文件名不要带上后缀名.ts, 否则会报错</strong>, 使用Es6模块化标准或者CommonJs标准都可以, 可以通过配置<strong>module</strong>来控制编译后js文件使用的模块化标准</h3>
<ul>
<li><h3 id="模块解析策略此处不详细解释-详情请点击这里">模块解析策略(此处不详细解释, 详情请<a href="https://blog.csdn.net/yivisir/article/details/115575394">点击这里</a>)</h3>
<ul>
<li>classic: 经典解析策略</li>
<li>node: node解析策略</li>
</ul>
</li>
<li><h3 id="注意事项">注意事项</h3>
<ul>
<li>像是nodejs自带的库使用的是CommonJs模块化标准, 在ts使用后编译结果可能会有意外的错误, 建议这样导入<code>import * as fs from &#39;fs&#39;</code>, 而不是<code>import fs from &#39;fs&#39;</code>这样导入, 如果一定要这样导入, 那么需要配置esModuleInterop</li>
<li>如果想要在ts中书写commonJs模块化的代码具有类型检查, 则需要这样导出<code>export = {导出的内容}</code>, 这样导入<code>import 变量 = require(文件路径)</code></li>
<li><strong>尽量使用Es6模块化标准进行书写TypeScript</strong></li>
</ul>
</li>
</ul>
<h2 id="接口">接口</h2>
<h3 id="用于约束类、对象、函数的标准-使用关键字interface进行定义-接口可以继承-当直接给对象字面量赋值-会进行更加严格的判定">用于约束类、对象、函数的标准, 使用关键字interface进行定义, <strong>接口可以继承</strong>, 当直接给对象字面量赋值, 会进行更加严格的判定</h3>
<pre><code class="language-ts">    interface User {
        name: string,
        age: number,
        sex: 0 | 1,
        print(callback: (n: number) =&gt; {}): void
    }

    // 在约束对象时建议使用接口进行约束
    // type User = {
    //     name: string,
    //     age: number,
    //     sex: 0 | 1
    // }

    let user1: User = {
        name: &#39;maomao&#39;,
        age: 18,
        sex: 1,
        print(callback) {
            console.log(this)
            const result = callback(1)
        }
    }

    user1.print(demo)

    function demo (a) {
        console.log(a)
        return a
    }

    // 接口继承
    interface A {
        name: string
    }

    interface B extends A {
        age: number
    }

    interface C {
        sex: 0 | 1
    }

    interface D extends A, C {
        phone: string
    }

    const user2: B = {
        name: &#39;CodeGorgeous&#39;,
        age: 21
    }

    const user3: D = {
        name: &#39;admin&#39;,
        sex: 0,
        phone: &quot;176xxxx0940&quot;
    }
    // 交叉类型
    type A = {
        name: string
    }

    type B = {
        age: number
    }

    type C = {
        age: boolean
    } &amp; A &amp; B

    // C: never
    const user1:C = {
        name: &#39;1&#39;, // never类型
        age: 1, // never类型
    }
</code></pre>
<ul>
<li><h3 id="接口的继承和类型别名的交叉类型的区别">接口的继承和类型别名的交叉类型的区别:</h3>
<ul>
<li>子接口不能重复定义父接口的key的类型, 而交叉类型可以</li>
<li>交叉类型中重复定义某个key类型则会使得类型进行叠加(经实测, 不同类型不管怎么叠加最后都会成为never类型)</li>
</ul>
</li>
</ul>
<h2 id="类型兼容性">类型兼容性</h2>
<h3 id="请在下面的代码中感受一下类型兼容性鸭子辩型法">请在下面的代码中感受一下类型兼容性(鸭子辩型法)</h3>
<pre><code class="language-ts">    interface User {
        name: string,
        sex: &#39;男&#39; | &#39;女&#39;
    }

    // const user1:A = {name: &#39;admin&#39;, age: 10} // age: 10报错

    let user2: User

    const user3 = {
        name: &#39;admin&#39;,
        sex: &#39;男&#39; as &#39;男&#39;, // 在这里可以进行类型断言
        age: 20
    }

    user2 = user3 // 这种操作可以称之为类型兼容性, 也称之为鸭子辨型法
</code></pre>
<h2 id="类型断言">类型断言</h2>
<h3 id="当写代码时十分明确该数据的类型-可以使用关键字as进行类型断言--数据-as-类型">当写代码时十分明确该数据的类型, 可以使用关键字as进行类型断言, <code> 数据 as 类型</code></h3>
<h2 id="类">类</h2>
<h3 id="在ts中需要使用属性列表描述constructor内所创建的值">在Ts中需要使用属性列表描述constructor内所创建的值</h3>
<pre><code class="language-ts">    class User {
        name: string
        private password: string
        readonly pid?: string
        sex: &#39;男&#39; | &#39;女&#39;
        constructor(name: string, password: string, pid?: string, sex: &#39;男&#39; | &#39;女&#39; = &#39;男&#39;) {
            this.name = name
            this.password = password
            this.pid = pid
            this.sex = sex
        }
        private print() {
            console.log(this.password)
        }
    }

    const user1 = new User(&#39;cg&#39;, &#39;123123&#39;, &#39;123541325132412&#39;)
    // user1.pid = &#39;2131254215123123&#39; // 无法分配到 &quot;pid&quot; ，因为它是只读属性。
    // user1.print() // 方法也可以私有化, 属性“print”为私有属性，只能在类“User”中访问。
    console.log(user1) // 正常输出
    // user1.password = &#39;3514124312&#39; // 属性“password”为私有属性，只能在类“User”中访问。
</code></pre>
<h2 id="泛型">泛型</h2>
<h3 id="附属于函数、类、接口、类型别名之上的类型称之为泛型">附属于函数、类、接口、类型别名之上的类型称之为泛型</h3>
<pre><code class="language-ts">    // 函数中使用泛型
    // &lt;T&gt;用于定义一个泛型
    function mySplice&lt;T&gt;(arr: T[], i: number): T[] {
        let result: T[] = []
        result = arr.splice(0, i)
        return result
    }
    // &lt;number&gt;相当于给&lt;T&gt;进行赋值, 此时T就代表number
    const result = mySplice&lt;number&gt;([1,2,3,4,5,6], 3) // 这里result类型为number[]
    // 这里省略赋值, Ts则会自动根据传递的参数进行类型推导
    const result1 = mySplice([1,&#39;2&#39;,true,8,5,[]], 3) // 这里推到为(string | number | boolean | never[])[]

    // 在类型别名/接口中使用泛型

    type A&lt;T&gt; = {
        name: T,
        id: T
    }


    type B&lt;T&gt; = (a: T, b: number) =&gt; boolean

    interface C&lt;T&gt; {
        (a: T, b: number): boolean
    }

    function myFilter&lt;T&gt;(arr: T[], callback: C&lt;T&gt;): T[] {
        const result: T[] = []
        arr.forEach((item, index) =&gt; {
            if (callback(item, index)) result.push(item)
        })
        return result
    }

    const result3 = myFilter&lt;number&gt;([1,2,3,4,5,6,7,8], (item, index) =&gt; item%2 === 0)

    console.log(result3)

    // 在类中使用泛型

    class ArrayHelper&lt;T&gt; {
        arr: T[]
        constructor(arr: T[]) {
            this.arr = arr
        }
        print(): T[] {
            return this.arr
        }
        indexOf(val: any): number {
            for (let i = 0; i &lt; this.arr.length; i++) {
                if (this.arr[i] === val) {
                    return i
                }
            }
            return -1
        }
        
    }

    const result4 = new ArrayHelper&lt;number&gt;([1,2,3,4,5])

    console.log(result4.print()) // 这里就会明确输出的是一个number[]
</code></pre>
<h3 id="泛型约束">泛型约束</h3>
<h4 id="使用关键字extends进行继承接口类型别名的约束">使用关键字extends进行继承接口/类型别名的约束</h4>
<pre><code class="language-ts">
type A = {
    a: number,
    b: number
}

interface B {
    a: number,
    b: number
}

// 使用关键字extends进行约束泛型, 可以继承接口、类型别名等
function sum&lt;T extends B&gt; (obj: T): number {
    return obj.a + obj.b;
}

const result = sum({
    a: 1,
    b: 2,
    c: 3
})

console.log(result) // 3
</code></pre>
<h3 id="多泛型">多泛型</h3>
<pre><code class="language-ts">    function mixinArray&lt;T, U&gt;(arr1: T[], arr2: U[]): (T | U)[] {
        let len = arr1.length
        let result: (T | U)[] = []
        if (arr1.length &lt; arr2.length) len = arr2.length
        for (let i = 0; i &lt; len; i++) {
            if (i &lt; arr1.length) result.push(arr1[i])
            if (i &lt; arr2.length) result.push(arr2[i])
        }
        return result
    }

    const result = mixinArray&lt;number, string&gt;([1, 3, 5, 2, 9],[&#39;a&#39;, &#39;c&#39;, &#39;b&#39;])

    console.log(result)
</code></pre>
<h2 id="访问器">访问器</h2>
<h3 id="用于控制属性的读取get和赋值set">用于控制属性的读取(get)和赋值(set)</h3>
<pre><code class="language-ts">    class User {
        name: string
        constructor(name: string, private _age: number) {
            this.name = name
            this._age = _age
        }
        
        public set age(v : number) {
            console.log(&#39;开始赋值&#39;)
            this._age = v;
        }
        
        
        public get age() : number {
            console.log(&#39;开始读取&#39;)
            return this._age
        }
        
    }

    const user1 = new User(&#39;cg&#39;, 21)

    user1.age = 22
    console.log(user1) // User { _age: 22, name: &#39;cg&#39; }
</code></pre>
<h2 id="修饰符">修饰符</h2>
<ul>
<li>readonly<ul>
<li>只读修饰符</li>
<li>不会在编译后显示</li>
<li><strong>细节注意:</strong> 当该修饰符出现在这种情况下<code>const arr1: readonly number[] = [1, 2, 3]</code>时, 表示的是该数组是无法进行任何改变的(不能进行push等等这种操作), 出现在这种情况下<code>const Demo {readonly arr1: number[]}</code>时, 表示该数组是可以进行改变的(能进行push这种操作), 但是两种情况都不能允许对数据的地址产生任何改变</li>
</ul>
</li>
</ul>
<pre><code class="language-ts">    interface User {
        readonly id: string,
        name: string,
        age: number,
    }

    const user1: User = {
        id: &#39;1&#39;,
        name: &#39;maomao&#39;,
        age: 18
    }

    // user1.id = &#39;2&#39;   // 无法分配到 &quot;id&quot; ，因为它是只读属性
</code></pre>
<ul>
<li><p>public/private</p>
<ul>
<li>访问修饰符</li>
<li>控制类中某个成员的访问权限</li>
<li>public 公开的权限, private 私有的权限, 只能够在类中进行</li>
<li>不会在编译后显示
```ts
  class User {
  name: string
  private password: string
  readonly pid?: string
  sex: &#39;男&#39; | &#39;女&#39;
  constructor(name: string, password: string, pid?: string, sex: &#39;男&#39; | &#39;女&#39; = &#39;男&#39;) {
  this.name = name
  this.password = password
  this.pid = pid
  this.sex = sex
  }
  private print() {
  console.log(this.password)
  }
  }</li>
</ul>
<p>  const user1 = new User(&#39;cg&#39;, &#39;123123&#39;, &#39;123541325132412&#39;)
  // user1.pid = &#39;2131254215123123&#39; // 无法分配到 &quot;pid&quot; ，因为它是只读属性。
  // user1.print() // 方法也可以私有化, 属性“print”为私有属性，只能在类“User”中访问。
  console.log(user1) // 正常输出
  // user1.password = &#39;3514124312&#39; // 属性“password”为私有属性，只能在类“User”中访问。</p>
</li>
</ul>
<pre><code>
## 在React中使用Ts

```ts
// ***index.tsx***
import Demo from &#39;@/components/Demo&#39;
import React, { useState } from &#39;react&#39;

export default function IndexPage() {

  const [Num, setNum] = useState(0)

  return (
    &lt;div&gt;
      &lt;h1&gt;Hello React+Ts&lt;/h1&gt;
      &lt;Demo
        num={Num}
        onChange={(val) =&gt; {
          setNum(Num + val)
        }}
      /&gt;
    &lt;/div&gt;
  );
}

// ***Demo/index.tsx***
import React from &#39;react&#39;
import style from &#39;./index.less&#39;

interface Props {
    num: number
    onChange?: (val: number) =&gt; void
}

// 两种写法
//  第一种
// export default function index(props: Props) {
//     return (
//         &lt;div&gt;
//             &lt;button
//                 className={style.button}
//                 onClick={() =&gt; {
//                     props.onChange &amp;&amp; props.onChange(-1)
//                 }}
//             &gt;-&lt;/button&gt;
//             &lt;h1&gt;{props.num}&lt;/h1&gt;
//             &lt;button
//                 className={style.button}
//                 onClick={() =&gt; {
//                     props.onChange &amp;&amp; props.onChange(1)
//                 }}
//             &gt;+&lt;/button&gt;
//         &lt;/div&gt;
//     )
// }

// 第二种

const index: React.FC&lt;Props&gt; = (props) =&gt; {
    return (
        &lt;div&gt;
            &lt;button
                className={style.button}
                onClick={() =&gt; {
                    props.onChange &amp;&amp; props.onChange(-1)
                }}
            &gt;-&lt;/button&gt;
            &lt;h1&gt;{props.num}&lt;/h1&gt;
            &lt;button
                className={style.button}
                onClick={() =&gt; {
                    props.onChange &amp;&amp; props.onChange(1)
                }}
            &gt;+&lt;/button&gt;
        &lt;/div&gt;
    )
}

export default index
</code></pre>
<style>
    body {
        margin: 0 auto;
        font-family: "ubuntu", "Tahoma", "Microsoft YaHei", arial, sans-serif;
        color: #444444;
        line-height: 1;
        padding: 30px;
    }
    
    img {
        display: block;
        max-width: 100%;
        margin: 0 auto;
    }
    
    @media screen and (min-width: 1000px) {
        body {
            width: 842px;
            margin: 10px auto;
        }
    }
    
    h1,
    h2,
    h3,
    h4 {
        color: #111111;
        font-weight: 400;
        margin-top: 1em;
    }
    
    h1,
    h2,
    h3,
    h4,
    h5 {
        font-family: Georgia, Palatino, serif;
    }
    
    h1,
    h2,
    h3,
    h4,
    h5,
    dl {
        margin-bottom: 16px;
        padding: 0;
    }
    
    p {
        margin-top: 8px;
        margin-bottom: 3px;
    }
    
    h1 {
        font-size: 48px;
        line-height: 54px;
    }
    
    h2 {
        font-size: 36px;
        line-height: 42px;
    }
    
    h1,
    h2 {
        border-bottom: 1px solid #EFEAEA;
        padding-bottom: 10px;
    }
    
    h3 {
        font-size: 24px;
        line-height: 30px;
    }
    
    h4 {
        font-size: 21px;
        line-height: 26px;
    }
    
    h5 {
        font-size: 18px;
        line-height: 23px;
    }
    
    a {
        color: #0099ff;
        margin: 0 2px;
        padding: 0;
        vertical-align: baseline;
        text-decoration: none;
    }
    
    a:hover {
        text-decoration: none;
        color: #ff6600;
    }
    
    ul,
    ol {
        padding: 0;
        padding-left: 18px;
        margin: 0;
    }
    
    li {
        line-height: 24px;
    }
    
    p,
    ul,
    ol {
        font-size: 16px;
        line-height: 24px;
    }
    
    ol ol,
    ul ol {
        list-style-type: lower-roman;
    }
    
    code,
    pre {
        font-family: Consolas, Monaco, Andale Mono, monospace;
        background-color: #f7f7f7;
        color: inherit;
    }
    
    code {
        font-family: Consolas, Monaco, Andale Mono, monospace;
        margin: 0 2px;
    }
    
    pre {
        font-family: Consolas, Monaco, Andale Mono, monospace;
        line-height: 1.7em;
        overflow: auto;
        padding: 6px 10px;
        border-left: 5px solid #6CE26C;
    }
    
    pre>code {
        font-family: Consolas, Monaco, Andale Mono, monospace;
        border: 0;
        display: inline;
        max-width: initial;
        padding: 0;
        margin: 0;
        overflow: initial;
        line-height: 1.6em;
        font-size: .95em;
        white-space: pre;
        background: 0 0;
    }
    
    code {
        color: #666555;
    }
    
    aside {
        display: block;
        float: right;
        width: 390px;
    }
    
    blockquote {
        border-left: .5em solid #eee;
        padding: 0 0 0 2em;
        margin-left: 0;
    }
    
    blockquote cite {
        font-size: 14px;
        line-height: 20px;
        color: #bfbfbf;
    }
    
    blockquote cite:before {
        content: '\2014 \00A0';
    }
    
    blockquote p {
        color: #666;
    }
    
    hr {
        text-align: left;
        color: #999;
        height: 2px;
        padding: 0;
        margin: 16px 0;
        background-color: #e7e7e7;
        border: 0 none;
    }
    
    dl {
        padding: 0;
    }
    
    dl dt {
        padding: 10px 0;
        margin-top: 16px;
        font-size: 1em;
        font-style: italic;
        font-weight: bold;
    }
    
    dl dd {
        padding: 0 16px;
        margin-bottom: 16px;
    }
    
    dd {
        margin-left: 0;
    }
    
    table {
        *border-collapse: collapse;
        /* IE7 and lower */
        border-spacing: 0;
        width: 100%;
    }
    
    table {
        border: solid #ccc 1px;
    }
    
    table thead {
        background: #f7f7f7;
    }
    
    table thead tr:hover {
        background: #f7f7f7
    }
    
    table tr:hover {
        background: #fbf8e9;
        -o-transition: all 0.1s ease-in-out;
        -webkit-transition: all 0.1s ease-in-out;
        -moz-transition: all 0.1s ease-in-out;
        -ms-transition: all 0.1s ease-in-out;
        transition: all 0.1s ease-in-out;
    }
    
    table td,
    .table th {
        border-left: 1px solid #ccc;
        border-top: 1px solid #ccc;
        padding: 10px;
        text-align: left;
    }
    
    table th {
        border-top: none;
        text-shadow: 0 1px 0 rgba(255, 255, 255, .5);
        padding: 5px;
        border-left: 1px solid #ccc;
    }
    
    table td:first-child,
    table th:first-child {
        border-left: none;
    }
    
    body {
        width: 100%;
        height: 100%;
        padding: 0 !important;
    }
    
    .sidebar {
        width: 300px;
        height: 100%;
        border-right: 1px solid #aaa;
        position: fixed;
        top: 0;
        left: -300px;
        box-shadow: 2px 0 5px 3px #aaa;
        padding: 10px 0 0 0;
        box-sizing: border-box;
        transition: left 0.5s;
    }
    
    .sidebar-title {
        padding: 10px;
        border-bottom: 1px solid #ccc;
    }
    
    .sidebar-title a {
        color: #000000;
        font-weight: bold;
    }
    
    .sidebar-title a:hover {
        color: #666555;
    }
    
    .sidebar-title .sidebar-github {
        float: right;
    }
    
    .sidebar-content {
        width: 100%;
        height: 100%;
        box-sizing: border-box;
        padding: 10px 0 0 20px;
    }
    
    .sidebar-content div {
        margin: 5px 0px;
    }
    
    .sidebar-content div a {
        display: inline-block;
        font-size: 20px;
        width: 100%;
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
    }
    /* 内容区 */
    
    .markdown-box {
        display: flex;
        justify-content: center;
    }
    
    .content {
        display: inline-block;
        box-sizing: border-box;
        width: 80%;
        height: 100%;
        padding: 20px 20px 0 30px;
        position: relative;
        transition: margin-left 0.5s;
        overflow-x: hidden;
    }
    
    .loading-lock {
        position: fixed;
        top: 20px;
        left: 20px;
        padding: 7px 10px;
        border: 1px solid #ddd;
        border-radius: 5px;
        cursor: pointer;
        box-shadow: 0 0 8px 1px #aaa;
        transition: left 0.5s;
        background: #FFFFFF;
    }
    
    .loading-lock:active {
        box-shadow: inset 0 0 8px 1px #aaa;
    }
    /* 回到顶部按钮样式 */
    
    .backTop {
        width: 100px;
        line-height: 50px;
        text-align: center;
        position: fixed;
        bottom: 50px;
        right: 50px;
        display: none;
        border-radius: 50%;
        cursor: pointer;
    }
    
    h1 {
        margin-top: 0;
        padding-top: 1em;
    }
    /* 表格内容居中 */
    
    .content table td[align="center"] {
        text-align: center;
    }
    /* 表格内容靠右 */
    
    .content table td[align="right"] {
        text-align: right;
    }
</style>